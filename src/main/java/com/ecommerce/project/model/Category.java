package com.ecommerce.project.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

// Getters and Setters are important as JPA uses them to get and set their values and store them in db.
// If for any attribute, there are no getters and setters, then that attribute won't be shown in response and also its
// value in db will be null.

@Entity(name = "Categories")  // Categories will be the new table name
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Category {
    // Marking categoryId as unique identifier (primary key) using @Id annotation
    @Id
    // We can manage primary key within the application and make sure it is stored in db and is unique. But we can make
    // use of Generation types annotation to get this job to db. This annotation have strategy on how we want db to generate pk
    // (Types described below)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long categoryId;

    @NotBlank
    @Size(min = 3, message = "Category name must contain at least 3 characters")
    private String categoryName;

    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL)
    private List<Product> products;

//    Not needed becoz of Lombok annotations
//    public Category(Long categoryId, String categoryName) {
//        this.categoryId = categoryId;
//        this.categoryName = categoryName;
//    }
//
//    public Category() {
//    }
//
//    public Long getCategoryId() {
//        return categoryId;
//    }
//
//    public void setCategoryId(Long categoryId) {
//        this.categoryId = categoryId;
//    }
//
//    public String getCategoryName() {
//        return categoryName;
//    }
//
//    public void setCategoryName(String categoryName) {
//        this.categoryName = categoryName;
//    }
}


// Different GenerationType strategies
// 1. AUTO => This is the default generation strategy. It tells JPA provider that you should choose the appropriate
// strategy based on the underlying database. So what happens is normally there can be different database providers like
// MongoDB or PosgreSQL, etc. So depending on the database provider JPA will take care of how the values are generated.
// So you are just delegating this to the JPA okay.
// So let's say that application that you are building, you want it to work across different databases like MySQL for
// development and PostgreSQL for production. So you can make use of auto over here because you don't want to worry
// about specific primary key generation strategy supported by each database.

// 2. IDENTITY => This strategy uses an identity column in the database to generate primary key values. This is
// supported by relational databases like MySQL SQL server, PostgreSQL. This strategy is not supported by all the
// databases out there.

// 3. SEQUENCE => This strategy uses a database sequence to generate primary key values. Now what are sequences?
// Sequences are database objects that create unique numbers. It's an object that resides in the database and it
// generates a sequence of unique values. This strategy is commonly used with databases like Oracle and PostgreSQL that
// support sequences (currently).
// So if you are running a PostgreSQL database that manages the order and if you want to have each order as unique,
// you can define a sequence in PostgreSQL. By this, you can make use of JPA and you can tell JPA to use this sequence
// to generate a new unique.
//@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "order_seq")
//@SequenceGenerator(name = "order_seq", sequenceName = "order_seq", allocationSize = 1)
// Allocation size meaning one means every time a new order is received, you will have it incremented by one.
// So if you go through this we have ID field that marks the field as the primary key okay. Then we have this annotation
// which specifies the ID field that will be automatically generated by the database using a sequence. And we have a
// generator that links it. This strategy to the specific sequence generator named order underscore sequence okay.
// And then we have a sequence generator named order underscore sequence. And it specifies the name of the sequence in
// the database. So order underscore sequence is the name of the sequence.

// 4. TABLE => This strategy makes use of a table to simulate a sequence. It stores the next available value for the
// sequence in a separate table. Now this strategy is less efficient than using sequences directly. But this can be
// useful if your database does not support a sequence okay.
// This is a syntax and if you're building let's say a application. And if you want that application to run and make use
// of this table sequence, then you can define it this way. So you have ID. Then you have the generated value.
// You are specifying the table and the generator as task gen, and then you are specifying the generator details.
// So you are specifying that the table generator is task gen. The table is id underscore gen the column name, the value
// column name and everything. And this is being linked to the ID column.
//@GeneratedValue(strategy = GenerationType.TABLE, generator = "task_gen")
//@TableGenerator(name = "task_gen", table = "id_gen", pkColumnName = "gen_key", valueColumnName = "gen_value",
//        pkColumnValue = "task_id", allocationSize = 1)
